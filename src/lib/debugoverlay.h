// Copyright © 2016 Canonical Ltd.
// Author: Loïc Molinari <loic.molinari@canonical.com>
//
// This file is part of Quick+.
//
// Quick+ is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; version 3.
//
// Quick+ is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Quick+. If not, see <http://www.gnu.org/licenses/>.

// FIXME(loicm) Binary compat will be a pain if all that is exported as it is.

#ifndef DEBUGOVERLAY_H
#define DEBUGOVERLAY_H

#include <QtCore/QDebug>
#include <QtCore/QSize>
#include <QtCore/QPointF>
#include <QtCore/QString>
#include <QtCore/QElapsedTimer>
#include <QtGui/QVector4D>
#include <QtGui/qopengl.h>
#include <QtGui/QOpenGLContext>
#include <QtGui/QOpenGLFunctions>
#include <QtQuick/QQuickWindow>
#if defined(QT_OPENGL_ES)
#include <EGL/egl.h>
#include <EGL/eglext.h>
#endif
#include <sys/times.h>

// BitmapText renders a monospaced bitmap Latin-1 encoded text (128 characters)
// stored in a single texture atlas using OpenGL. The font is generated by
// bitmaptextbuilder (in the tools directory) and stored in the debugoverlayfont.h
// header.
class BitmapText
{
public:
    BitmapText();
    ~BitmapText();

    // Allocates/Deletes the OpenGL resources. finalise() is not called at
    // destruction, it must be explicitly called to free the resources at the
    // right time in a thread with the same OpenGL context bound than at
    // initialise().
    bool initialise();
    void finalise();

    // Sets the text. Characters below 32 and above 126 included are ignored
    // apart from line feeds (10). Implies a reallocation of internal data. Must
    // be called in a thread with the same OpenGL context bound than at
    // initialise().
    void setText(const char* text);

    // Updates the current text at the given index. In order to avoid expensive
    // layout updates, line feeds can't be added nor removed. Updates of
    // characters below 32 and above 126 in the new text are ignored.
    void updateText(const char* text, int index, int length);

    // Sets the viewport size. Must be set correctly prior to rendering for
    // correct results.
    void setViewportSize(const QSize& viewportSize);

    // Sets the text position with regards to the viewport size. Origin is at
    // top/left.
    void setPosition(const QPointF& position);

    // Renders the text. Must be called in a thread with the same OpenGL context
    // bound than at initialise().
    void render();

private:
    struct Vertex {
        float x, y, s, t;
    };
    enum {
        Initialised    = (1 << 0),
        DirtyTransform = (1 << 1),
        NotEmpty       = (1 << 2)
    };

    QOpenGLFunctions* m_functions;
    Vertex* m_vertexBuffer;
    char* m_textToVertexBuffer;
    QSize m_viewportSize;
    QPointF m_position;
    QVector4D m_transform;
    int m_textLength;
    int m_characterCount;
    int m_currentFont;
    GLuint m_program;
    GLint m_programTransform;
    GLuint m_vertexShaderObject;
    GLuint m_fragmentShaderObject;
    GLuint m_texture;
    GLuint m_indexBuffer;
    quint8 m_flags;
};

// GPUTimer is a timer used to measure the amount of time taken by the GPU to
// fully complete a set of graphics commands. As opposed to a basic timer which
// would determine the time taken by the graphics driver to push the graphics
// commands in the command buffer from the CPU, this timer pushes dedicated
// synchronisation commands the command buffer, which the GPU signals whenever
// completeted. That allows to get very accurate GPU timings.
class GPUTimer
{
public:
    GPUTimer() : m_type(NotInitialised), m_started(false) {}

    // Allocates/Deletes the OpenGL resources. finalise() is not called at
    // destruction, it must be explicitly called to free the resources at the
    // right time in a thread with the same OpenGL context bound than at
    // initialise().
    bool initialise();
    void finalise();

    // Starts/Stops the timer. stop() returns the time elapsed in nanoseconds
    // since the call to start(). Calling start() two times in a row before
    // stop() is simply ignored and doesn't reset the timer. Calling stop() two
    // times returns 0. Must be called in a thread with the same OpenGL context
    // bound than at initialise().
    void start();
    qint64 stop();

private:
    enum Type {
        NotInitialised,
#if defined(QT_OPENGL_ES)
        KHRFence,
        NVFence,
#else
        ARBTimerQuery,
        EXTTimerQuery
#endif
    };
    Type m_type;
    bool m_started;

#if defined(QT_OPENGL_ES)
    struct {
        void (QOPENGLF_APIENTRYP genFencesNV)(GLsizei n, GLuint* fences);
        void (QOPENGLF_APIENTRYP deleteFencesNV)(GLsizei n, const GLuint* fences);
        void (QOPENGLF_APIENTRYP setFenceNV)(GLuint fence, GLenum condition);
        void (QOPENGLF_APIENTRYP finishFenceNV)(GLuint fence);
    } m_fenceNV;
    GLuint m_fence[2];

    struct {
        EGLSyncKHR (QOPENGLF_APIENTRYP createSyncKHR)(EGLDisplay dpy, EGLenum type,
                                                      const EGLint* attrib_list);
        EGLBoolean (QOPENGLF_APIENTRYP destroySyncKHR)(EGLDisplay dpy, EGLSyncKHR sync);
        EGLint (QOPENGLF_APIENTRYP clientWaitSyncKHR)(EGLDisplay dpy, EGLSyncKHR sync, EGLint flags,
                                                      EGLTimeKHR timeout);
    } m_fenceSyncKHR;
    EGLSyncKHR m_beforeSync;

#else
    struct {
        void (QOPENGLF_APIENTRYP genQueries)(GLsizei n, GLuint* ids);
        void (QOPENGLF_APIENTRYP deleteQueries)(GLsizei n, const GLuint* ids);
        void (QOPENGLF_APIENTRYP beginQuery)(GLenum target, GLuint id);
        void (QOPENGLF_APIENTRYP endQuery)(GLenum target);
        void (QOPENGLF_APIENTRYP getQueryObjectui64v)(GLuint id, GLenum pname, GLuint64* params);
        void (QOPENGLF_APIENTRYP getQueryObjectui64vExt)(GLuint id, GLenum pname,
                                                         GLuint64EXT* params);
        void (QOPENGLF_APIENTRYP queryCounter)(GLuint id, GLenum target);
    } m_timerQuery;
    GLuint m_timer[2];
#endif
};

// // 
// class DebugOverlay : public QObject {
//     Q_OBJECT

// public:
//     // 
//     DebugOverlay(QQuickWindow* window);
//     ~DebugOverlay();

// private Q_SLOTS:
//     void windowDestroyed(QObject*);
//     void windowSizeChanged(int);
//     void windowSceneGraphInitialised();
//     void windowSceneGraphInvalidated();
//     void windowBeforeSynchronising();
//     void windowAfterSynchronising();
//     void windowBeforeRendering();
//     void windowAfterRendering();

// private:
//     enum UpdateFlag {
//         CpuUsage    = (1 << 0),
//         Memory      = (1 << 1),
//         FrameNumber = (1 << 2)
//     };

//     bool parseText(const char* text);
//     void updateCpuUsage();
//     void updateMemory();
//     void updateFrameCount();
//     void render();

//     char* m_text;
//     struct { quint16 typeIndex; quint16 textIndex; }* m_counters;
//     quint16 m_textSize;
//     quint8 m_countersSize;
//     quint8 m_updateFlags;

//     BitmapText m_bitmapText;
//     GpuTimer m_gpuTimer;

//     QElapsedTimer m_cpuTimer;
//     struct tms m_cpuTimes;
//     clock_t m_cpuTicks;
//     float m_cpuTimingFactor;
//     float m_cpuUsage;

//     int m_vszMemory;
//     int m_rssMemory;

//     int m_frameCount;

//     // FIXME(loicm) Check if we can just use one timer as sync'ing and rendering
//     //     aren't done at the same time (in case there's a rendering thread).
//     QElapsedTimer m_syncTimer;
//     QElapsedTimer m_renderTimer;
//     float m_syncTime;
//     float m_renderTime;

//     float m_gpuRenderTime;
// };

#endif  // DEBUGOVERLAY_H
