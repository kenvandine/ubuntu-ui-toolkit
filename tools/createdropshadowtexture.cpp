// Copyright © 2015 Canonical Ltd.
// Author: Loïc Molinari <loic.molinari@canonical.com>
//
// This file is part of Quick+.
//
// Quick+ is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; version 3.
//
// Quick+ is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Quick+. If not, see <http://www.gnu.org/licenses/>.

// In order to generate a new file, the following commands must be used:
// $ cd tools
// $ qmake && make
// $ ./createdropshadowtexture ../src/dropshadowtexture.h

#include <QtCore/QFile>
#include <QtCore/QTextStream>
#include <QtGui/QImage>

const int baseLevelSize = 256;
const int mipmapCount = 9;  // There are 9 levels from 256 to 1.

static double data[baseLevelSize * baseLevelSize];
static double temp[baseLevelSize * baseLevelSize];
static double kernel[baseLevelSize];

Q_STATIC_ASSERT((baseLevelSize >= 16) && !((baseLevelSize - 1) & baseLevelSize));

static void render(double* data, int size)
{
    Q_ASSERT(size >= 1);

    const int width = size;
    const int height = size;
    const int dataSize = width * height;
    const int kernelSize = size > 1 ? size - 1 : 2;
    const int halfKernelSize = kernelSize / 2;
    double kernelSum = 0.0;

    // Clear buffers.
    memset(data, 0, baseLevelSize * baseLevelSize * sizeof(double));
    memset(temp, 0, baseLevelSize * baseLevelSize * sizeof(double));
    memset(kernel, 0, baseLevelSize * sizeof(double));

    // Generate the gaussian kernel.
    const double std = 20.0 * (width / 128.0);
    for (int i = 0; i < kernelSize; i++) {
        const double f = i - halfKernelSize;
        kernel[i] = exp(-f * f / (2.0 * std * std));
        kernelSum += kernel[i];
    }

    // Fill source buffer with a white rectangle at (width/2, height/2).
    for (int i = height / 2; i < height; i++) {
        for (int j = width / 2; j < width; j++) {
            data[width * i + j] = 1.0;
        }
    }

    // Compute the gaussian blur using separate horizontal and vertical passes.
    for (int i = 0; i < height; i++) {
        double* src = &data[width * i];
        double* dst = &temp[width * i];
        for (int j = 0; j < width; j++) {
            double x = 0;
            for (int k = 0; k < kernelSize; k++) {
                x += src[qBound(0, j - halfKernelSize + k, width - 1)] * kernel[k];
            }
            dst[j] = x / kernelSum;
        }
    }
    for (int i = 0; i < height; i++) {
        double* src = &temp[width * i];
        double* dst = &data[width * i];
        for (int j = 0; j < width; j++) {
            double x = 0;
            for (int k = 0; k < kernelSize; k++) {
                src = &temp[width * qBound(0, (i - halfKernelSize + k), height - 1)];
                x += src[j] * kernel[k];
            }
            dst[j] = x / kernelSum;
        }
    }

    // Scale and clamp all the values so that once mapped on the scene graph
    // geometry, texels on the edge are set to 1.0, making shadow opacity
    // changes a single multiplication.
    const double scale = 1.0 / data[(width * (height / 2)) + (width - 1)];
    for (int i = 0; i < dataSize; i++) {
        data[i] = qMin(1.0, data[i] * scale);
    }
}

static void dump(QTextStream& cppOut, const double* data, int size)
{
    cppOut.setIntegerBase(16);
    for (int i = 0; i < size * size; i++) {
        cppOut << ((i % 16 != 0) ? "," : ((i != 0) ? ",\n    " : "    ")) << "0x"
               << qSetFieldWidth(2) << qSetPadChar('0')
               << static_cast<int>(data[i] * 255.0 + 0.5)  // Quantization.
               << qSetFieldWidth(0) << qSetPadChar(' ');
    }
    cppOut.setIntegerBase(10);
}

int main(int argc, char* argv[])
{
    if (argc != 2) {
        qWarning("Usage: createdropshadowtexture filename");
        return 1;
    }

    QFile cppFile(argv[1]);
    if (!cppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning("Can't create C++ header file \'%s\'", argv[1]);
        return 1;
    }

    QTextStream cppOut(&cppFile);
    cppOut << "// Copyright 2015 Canonical Ltd.\n"
           << "// Automatically generated by the createdropshadowtexture tool.\n"
           << "\n"
           << "const int dropShadowBaseLevelSize = " << baseLevelSize << ";\n"
           << "const int dropShadowMipmapCount = " << mipmapCount << ";\n"
           << "const int dropShadowOffsets[" << mipmapCount << "] = { 0";
    int offset = 0;
    for (int i = 0; i < mipmapCount - 1; i++) {
        offset += (baseLevelSize >> i) * (baseLevelSize >> i);
        cppOut << ", " << offset;
    }
    offset += (baseLevelSize >> (mipmapCount - 1)) * (baseLevelSize >> (mipmapCount - 1));
    cppOut << " };\n\n"
           << "static const unsigned char dropShadowData[" << offset << "] = {\n";
    for (int i = 0; i < mipmapCount; i++) {
        render(data, baseLevelSize >> i);
        cppOut << (i ? ",\n\n" : "") << "    // Mipmap level " << i << ".\n";
        dump(cppOut, data, baseLevelSize >> i);
    }
    cppOut << "\n};\n";

    // Save the texture data as a grayscale image for debugging purpose
    // (requires Qt 5.5).
    // render(data, baseLevelSize);
    // QImage image(data, baseLevelSize, baseLevelSize, baseLevelSize, QImage::Format_Grayscale8);
    // image.save("dropshadowtexture.png");

    return 0;
}
