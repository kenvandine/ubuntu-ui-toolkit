// Copyright © 2015 Canonical Ltd.
// Author: Loïc Molinari <loic.molinari@canonical.com>
//
// This file is part of Quick+.
//
// Quick+ is free software: you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; version 3.
//
// Quick+ is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
// details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Quick+. If not, see <http://www.gnu.org/licenses/>.

// In order to generate a new file, the following commands must be used:
// $ cd tools
// $ qmake && make
// $ ./createdropshadowtexture ../src/dropshadowtexture.h

#include <QtCore/QFile>
#include <QtCore/QTextStream>
#include <QtGui/QImage>

const int baseLevelSize = 256;
const int mipmapCount = 9;  // There are 9 levels from 256 to 1.

static quint8 data[baseLevelSize * baseLevelSize];
static quint8 temp[baseLevelSize * baseLevelSize];
static quint8 kernel[baseLevelSize];

Q_STATIC_ASSERT((baseLevelSize >= 16) && !((baseLevelSize - 1) & baseLevelSize));

static void render(quint8* data, int size)
{
    Q_ASSERT(size >= 1);

    const int width = size;
    const int height = size;
    const int dataSize = width * height;
    const int kernelSize = size > 1 ? size - 1 : 2;
    const int halfKernelSize = kernelSize / 2;
    int kernelSum = 0;

    // Clear buffers.
    memset(data, 0, baseLevelSize * baseLevelSize);
    memset(temp, 0, baseLevelSize * baseLevelSize);
    memset(kernel, 0, baseLevelSize);

    // Generate the gaussian kernel.
    const float std = 20.0 * (width / 128.0);
    for (int i = 0; i < kernelSize; i++) {
        int f = i - halfKernelSize;
        kernel[i] = static_cast<int>(255.0 * exp(-f * f / (2.0 * std * std)));
        kernelSum += kernel[i];
    }

    // Fill source buffer with a white rectangle at (width/2, height/2).
    for (int i = height / 2; i < height; i++) {
        for (int j = width / 2; j < width; j++) {
            data[width * i + j] = 255;
        }
    }

    // Compute the gaussian blur using separate horizontal and vertical passes.
    for (int i = 0; i < height; i++) {
        quint8* src = &data[width * i];
        quint8* dst = &temp[width * i];
        for (int j = 0; j < width; j++) {
            int x = 0;
            for (int k = 0; k < kernelSize; k++) {
                x += src[qBound(0, j - halfKernelSize + k, width - 1)] * kernel[k];
            }
            dst[j] = x / kernelSum;
        }
    }
    for (int i = 0; i < height; i++) {
        quint8* src = &temp[width * i];
        quint8* dst = &data[width * i];
        for (int j = 0; j < width; j++) {
            int x = 0;
            for (int k = 0; k < kernelSize; k++) {
                src = &temp[width * qBound(0, (i - halfKernelSize + k), height - 1)];
                x += src[j] * kernel[k];
            }
            dst[j] = x / kernelSum;
        }
    }

    // Scale and clamp all the values so that once mapped on the scene graph
    // geometry node, the highest mapped value is 255 (1.0) making shadow
    // opacity changes a single multiplication.
    const float scale = 255.0f / data[(width * (height / 2)) + (width - 1)];
    for (int i = 0; i < dataSize; i++) {
        data[i] = static_cast<quint8>(qMin(255.0f, data[i] * scale));
    }
}

static void dump(QTextStream& cppOut, const quint8* data, int size)
{
    cppOut.setIntegerBase(16);

    const int squaredSize = size * size;
    for (int i = 0; i < squaredSize; i++) {
        if (i % 16 == 0) {
            if (i != 0) {
                cppOut << ",\n    ";
            } else {
                cppOut << "    ";
            }
        } else {
            cppOut << ",";
        }
        cppOut << "0x"
               << qSetFieldWidth(2) << qSetPadChar('0')
               << data[i]
               << qSetFieldWidth(0) << qSetPadChar(' ');
    }

    cppOut.setIntegerBase(10);
}

int main(int argc, char* argv[])
{
    if (argc != 2) {
        qWarning("Usage: createdropshadowtexture filename");
        return 1;
    }

    QFile cppFile(argv[1]);
    if (!cppFile.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning("Can't create C++ header file \'%s\'", argv[1]);
        return 1;
    }

    QTextStream cppOut(&cppFile);
    cppOut << "// Copyright 2015 Canonical Ltd.\n"
           << "// Automatically generated by the createdropshadowtexture tool.\n"
           << "\n"
           << "const int dropShadowBaseLevelSize = " << baseLevelSize << ";\n"
           << "const int dropShadowMipmapCount = " << mipmapCount << ";\n"
           << "const int dropShadowOffsets[" << mipmapCount << "] = { 0";
    int offset = 0;
    for (int i = 0; i < mipmapCount - 1; i++) {
        offset += (baseLevelSize >> i) * (baseLevelSize >> i);
        cppOut << ", " << offset;
    }
    offset += (baseLevelSize >> (mipmapCount - 1)) * (baseLevelSize >> (mipmapCount - 1));
    cppOut << " };\n\n"
           << "static const unsigned char dropShadowData[" << offset << "] = {\n";
    for (int i = 0; i < mipmapCount; i++) {
        render(data, baseLevelSize >> i);
        cppOut << (i ? ",\n\n" : "") << "    // Mipmap level " << i << ".\n";
        dump(cppOut, data, baseLevelSize >> i);
    }
    cppOut << "\n};\n";

    // Save the texture data as a grayscale image for debugging purpose
    // (requires Qt 5.5).
    // render(data, baseLevelSize);
    // QImage image(data, baseLevelSize, baseLevelSize, baseLevelSize, QImage::Format_Grayscale8);
    // image.save("dropshadowtexture.png");

    return 0;
}
